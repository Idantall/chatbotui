You’re right—the “continuation-only” vibe is because the server is always nudging the run with “don’t repeat greeting”. Make it first-turn only.

Here’s a tight patch:

Server: /api/chat (detect first turn → only then add the nudge)

Replace your current handler with this one:

app.post('/api/chat', async (req, res) => {
  try {
    const userText = (req.body?.user ?? '').toString().trim();
    const threadId = (req.body?.threadId ?? '').toString().trim();
    if (!userText) return res.status(400).json({ error: 'Empty message' });
    if (!threadId) return res.status(400).json({ error: 'Missing threadId' });

    // 0) Is this the first turn in this thread?
    //    (Thread is created on mount with no messages.)
    const prev = await openai.beta.threads.messages.list(threadId, { limit: 1 });
    const isFirstTurn = prev.data.length === 0;

    // 1) Append the user message
    await openai.beta.threads.messages.create(threadId, {
      role: 'user',
      content: userText
    });

    // 2) Run the assistant
    //    - On FIRST turn: no extra instructions -> Assistant uses its own full intro & flow
    //    - On FOLLOW-UP turns: append a gentle nudge not to repeat the intro
    const run = await openai.beta.threads.runs.createAndPoll(threadId, {
      assistant_id: 'asst_YwWtBI8O0YtanpYBstRDQxNN',
      ...(isFirstTurn ? {} : {
        additional_instructions:
          'זו פנייה המשכית באותו הסשן; אל תחזרי על נוסח הפתיחה או שאלת המגדר—המשיכי מנקודת העבודה הבאה.'
      })
    });

    if (run.status === 'requires_action') {
      return res.json({
        text: 'Assistant requested tool calls; this minimal server does not handle tool outputs.',
        threadId
      });
    }
    if (run.status !== 'completed') {
      return res.status(500).json({ error: `Run status: ${run.status}`, threadId });
    }

    // 3) Return last assistant reply
    const msgs = await openai.beta.threads.messages.list(threadId, { limit: 50 });
    const assistantMsg = msgs.data.find(m => m.role === 'assistant');

    let text = '(no reply)';
    if (assistantMsg?.content?.length) {
      text = assistantMsg.content
        .filter(p => p.type === 'text' && p.text?.value)
        .map(p => p.text.value)
        .join('\n\n')
        .trim() || text;
    }

    res.json({ text, threadId, _debug: { isFirstTurn } });
  } catch (e) {
    console.error('[api/chat]', e);
    res.status(e.status || 500).json({ error: e.message });
  }
});

Why this fixes it

First message in a new thread → isFirstTurn === true → we don’t pass any extra instructions → RIKI delivers her full opening exactly per your system prompt.

Subsequent messages → the small additional_instructions only then kicks in, so she won’t repeat the greeting.

Cleanup checklist

Search your codebase for additional_instructions or instructions and ensure they don’t appear anywhere else (no leftovers from debugging).

Keep the thread bootstrap route as-is (POST /api/thread) so the first turn truly is the first in that thread.

Make sure the client still sends the threadId with every /api/chat call.