You’re hitting a classic ID mix-up during polling: the server is trying to call
/threads/undefined/runs/thread_... → the first param (thread) is undefined, and the second param (run) is actually a thread id. Easiest fix: don’t hand-roll polling. Use the SDK’s createAndPoll helper and create the thread up-front once per tab so threadId is never null.

Below is a tight, drop-in refactor that will “just work”:

1) Server: add a thread bootstrap route + use createAndPoll

a) Add this route (create one thread per browser tab; the client will call it once on mount):

app.post('/api/thread', async (req, res) => {
  try {
    const thread = await openai.beta.threads.create(); // no messages yet
    return res.json({ threadId: thread.id });         // e.g. "thread_abc..."
  } catch (err) {
    console.error('[thread.create]', err);
    return res.status(err.status || 500).json({ error: err.message || 'thread create failed' });
  }
});


b) Replace /api/chat with this version (note: no manual retrieve loop):

app.post('/api/chat', async (req, res) => {
  try {
    const userText = (req.body?.user ?? '').toString().trim();
    const threadId = (req.body?.threadId ?? '').toString().trim();
    if (!userText) return res.status(400).json({ error: 'Empty message' });
    if (!threadId) return res.status(400).json({ error: 'Missing threadId' });

    // 1) append user message
    await openai.beta.threads.messages.create(threadId, {
      role: 'user',
      content: userText
    });

    // 2) run assistant and poll until completed (SDK helper = fewer bugs)
    const isFollowUp = true; // since the thread already exists
    const run = await openai.beta.threads.runs.createAndPoll(threadId, {
      assistant_id: process.env.ASSISTANT_ID || 'asst_YwWtBI8O0YtanpYBstRDQxNN',
      instructions: isFollowUp
        ? 'זו פנייה המשכית באותו הסשן; אל תחזרי על נוסח הפתיחה או שאלת המגדר—המשיכי מנקודת העבודה הבאה.'
        : undefined
    });

    if (run.status === 'requires_action') {
      return res.json({
        text: 'Assistant requested tool calls; this minimal server does not handle tool outputs.',
        threadId
      });
    }
    if (run.status !== 'completed') {
      return res.status(500).json({ error: `Run status: ${run.status}`, threadId });
    }

    // 3) fetch last assistant message
    const msgs = await openai.beta.threads.messages.list(threadId, { limit: 50 });
    const assistantMsg = msgs.data.find(m => m.role === 'assistant');

    let text = '(no reply)';
    if (assistantMsg?.content?.length) {
      text = assistantMsg.content
        .filter(p => p.type === 'text' && p.text?.value)
        .map(p => p.text.value)
        .join('\n\n')
        .trim() || text;
    }

    return res.json({ text, threadId });
  } catch (err) {
    console.error('[api/chat]', err);
    return res.status(err.status || 500).json({
      error: err.message || 'OpenAI error',
      code: err.code,
      type: err.type
    });
  }
});


createAndPoll is the officially recommended helper to avoid manual polling errors and param mix-ups. 
platform.openai.com
OpenAI Community

Make sure your SDK is current:

npm i openai@latest

2) Client: always get a threadId before sending messages

On app mount, create a thread once and keep the id in React state (no storage → new thread on refresh).

// chat.tsx (or App.jsx)
const [threadId, setThreadId] = useState<string | null>(null);

useEffect(() => {
  (async () => {
    try {
      const r = await fetch('/api/thread', { method: 'POST' });
      const data = await r.json();
      setThreadId(data.threadId);               // e.g. "thread_abc..."
      console.log('Bootstrapped threadId:', data.threadId);
    } catch (e) {
      console.error('Failed to create thread:', e);
    }
  })();
}, []);


When sending:

async function send(e?: React.FormEvent) {
  e?.preventDefault();
  if (!input.trim() || !threadId) return;      // ensure threadId exists

  console.log('Sending with threadId:', threadId);
  const r = await fetch('/api/chat', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ user: input.trim(), threadId })
  });
  const data = await r.json();
  console.log('Response threadId:', data.threadId); // should echo same id
  // ...render data.text...
}


Optional New Chat button (resets per-tab memory):

function newChat() {
  setMsgs([]);
  setThreadId(null);
  // Re-bootstrap a fresh thread:
  fetch('/api/thread', { method: 'POST' })
    .then(r => r.json())
    .then(d => setThreadId(d.threadId));
}

3) Quick sanity checks

Open POST /api/thread in Network tab → response must include "threadId":"thread_...".

First message request body must include that threadId.

Server logs should never show /threads/undefined/... anymore.

If you still see 500, hit npm ls openai and ensure you’re on a recent 4.x that supports createAndPoll.

4) Why this fixes your exact error

Your trace shows runs.retrieve was called with threadId = undefined and runId = "thread_...". By creating the thread first and using createAndPoll(threadId, …), the SDK constructs the correct path (/threads/{threadId}/runs/{runId}) and manages the polling details for you. This removes the parameter ordering pitfall entirely. The approach also aligns with the current Assistants docs for running an assistant on a thread. 
platform.openai.com
+1